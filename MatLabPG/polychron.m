% Finds polychronous groups in the workspace generated by spnet.m
% and saved in the matlab file fname, e.g., fname = '3600.mat';
% Created by Eugene M.Izhikevich.           November 21, 2005
% Modified on April 2, 2008 based on suggestions of Petra Vertes (UK).

% Main idea: for each mother neuron, consider various combinations of 
% pre-synatic (anchor) neurons and see whether any activity of a silent
% network could emerge if these anchors are fired. 

initOn = 1;
global a d N D pp s ppre dpre post pre delay T

if initOn==1
    % params to be tuned
    sm = 18 ;%max synaptic weight
    sm_threshold = 0.90*sm;
    E_IsynEfficRatio = 1.0
        
    % val from the simulation
    M = 50; %number of syn per neurons
    ExcitDim = 32;
    InhibDim = 16;
    nLayers = 4;
    N = (ExcitDim*ExcitDim+InhibDim*InhibDim)*nLayers;% N: num neurons
    D = 30; % D: max delay

    % izhikevich model params:
    a = zeros(N,1)+0.02;%todo check what this number is
    d = zeros(N,1)+2;
    

    % load data;
    preIDs_loaded = load('../Results/Neurons_NetworkPre.bin');
    postIDs_loaded = load('../Results/Neurons_NetworkPost.bin');
    weights_loaded = load('../Results/Neurons_NetworkWeights.bin');
    delays_loaded = load('../Results/Neurons_NetworkDelays.bin');

    cond = find(preIDs_loaded>=0);
    preIDs_loaded = preIDs_loaded(cond)+1; %index start from 1 in matlab
    postIDs_loaded = postIDs_loaded(cond)+1;
    weights_loaded = weights_loaded(cond);
    delays_loaded = delays_loaded(cond);

    %uncomment the command below to test the algorithm for shuffled (randomized e->e) synapses
    %e2e = find(s>=0 & post<Ne); s(e2e) = s(e2e(randperm(length(e2e))));

    groups={};          % the list of all polychronous groups
    anchor_width=3;     % the number of anchor neurons, from which a group starts
    min_group_path=4%7;   % discard all groups having shorter paths from the anchor neurons 
    T=150;              % the max length of a group to be considered;
                        % longer groups will be cut at t=T


    % Make necessary initializations to speed-up simulations.

    %find max numPostSynCon:
    maxNumPostSynCon = 0;
    for i=1:N
        postListLen = length(find(preIDs_loaded==i));
        if maxNumPostSynCon<postListLen
            maxNumPostSynCon = postListLen;
        end
    end;

    post = zeros(N,maxNumPostSynCon);
    delay = zeros(N,maxNumPostSynCon)+1;
    s = zeros(N,maxNumPostSynCon);
    

    for i=1:N
        cond = preIDs_loaded == i;

        delays_tmp = delays_loaded(cond);
        delay(i,1:length(delays_tmp))=delays_tmp;
        % This matrix provides the delay values for each synapse.
        %delay values of synapses that are connected from each presynaptic id i;
        % ie delay{i} return a list of delays of synapses that is connected from i

        post_tmp = postIDs_loaded(cond);
        post(i,1:length(post_tmp))=post_tmp;
        %post synaptic ids that are connected from each presynaptic id i;
        %ie post{i} return a list of ids of synapses that is connected from i

        s_tmp = weights_loaded(cond);
        s(i,1:length(s_tmp))=s_tmp*sm;
    end

    %This cell element tells who (indexes) the pre-synaptic neurons are; 
    % for i=1:N
    %     ppre{i}=mod( pre{i}, N);
    % end;

    %ppre and pre contain lists of presynaptic ids connected to post synaptic
    %cell i
    pre = cell(1,N);
    ppre = cell(1,N);

    for i=1:N
        cond = postIDs_loaded==i;
        ppre_tmp = preIDs_loaded(cond);
        ppre{i}=ppre_tmp;

        for j=1:length(ppre_tmp)
            pre{i}(j,1)=ppre_tmp(j)+N*(j+1);
        end
    end;


    % %This cell element tells what the presynaptic delay is; 
    for i=1:N
        dpre{i}=delay( pre{i} );
    end;

    %This cell element tells where to put PSPs in the matrix I (N by 1000)
    for i=1:N
        pp{i}=post(i,:)+N*(delay(i,:)-1);
    end;

    
    %remove small values for the synaptic weights:
    for l = 1:nLayers % set inhibitory synaptic weight negative
        i_begin = ExcitDim*ExcitDim*l + (InhibDim*InhibDim)*(l-1) + 1;
        i_end = (ExcitDim*ExcitDim+InhibDim*InhibDim)*l;
        s(i_begin:i_end,:)=s(i_begin:i_end,:)*-1*E_IsynEfficRatio;
    end
    s(find(s>0 & s<=sm_threshold))=0;%remove small vals
    
end


for i=1:(ExcitDim*ExcitDim)
    i
    anchors=1:anchor_width;                     % initial choice of anchor neurons
    strong_pre=find(s(pre{i})>sm_threshold);    % candidates for anchor neurons
    if length(strong_pre) >= anchor_width       % must be enough candidates
     while 1        % will get out of the loop via the 'break' command below 
        gr=polygroup( ppre{i}(strong_pre(anchors)), D-dpre{i}(strong_pre(anchors)) ); 
        
        %Calculate the longest path from the first to the last spike
        fired_path=sparse(N,1);        % the path length of the firing (from the anchor neurons)       
        for j=1:length(gr.gr(:,2))
            fired_path( gr.gr(j,4) ) = max( fired_path( gr.gr(j,4) ), 1+fired_path( gr.gr(j,2) ));
        end;
        
        longest_path = max(fired_path);
        
        if longest_path>=min_group_path 
            
            gr.longest_path = longest_path(1,1); % the path is a cell
            
            % How many times were the spikes from the anchor neurons useful?
            % (sometimes an anchor neuron does not participate in any
            % firing, because the mother neuron does its job; such groups
            % should be excluded. They are found when the mother neuron is
            % an anchor neuron for some other neuron).
            useful = zeros(1,anchor_width);
            anch = ppre{i}(strong_pre(anchors));
            for j=1:anchor_width
                useful(j) = length( find(gr.gr(:,2) == anch(j) ) );
            end;
       
            useful
            
            if all(useful>=2)
                
                groups{end+1}=gr;           % add found group to the list
                disp([num2str(round(100*i/N)) '%: groups=' num2str(length(groups)) ', size=' num2str(size(gr.firings,1)) ', path_length=' num2str(gr.longest_path)])   % display of the current status
            
                plot(gr.firings(:,1),gr.firings(:,2),'o');
                hold on;
                for j=1:size(gr.gr,1)
                    plot(gr.gr(j,[1 3 5]),gr.gr(j,[2 4 4]),'.-');
                end;
                axis([0 T 0 N]);
                hold off
                drawnow;
            end;
        end

        % Now, get a different combination of the anchor neurons
        k=anchor_width;
        while k>0 & anchors(k)==length(strong_pre)-(anchor_width-k)
            k=k-1;
        end;
        
        if k==0, break, end;    % exhausted all possibilities
        
        anchors(k)=anchors(k)+1;
        for j=k+1:anchor_width
            anchors(j)=anchors(j-1)+1;
        end;
        
        pause(0); % to avoid feezing when no groups are found for long time
        
     end;
    end;
end;
