* DONE Add CMake build scripts
CLOSED: [2016-11-11 Fri 14:00]
:LOGBOOK:
- State "DONE"       from              [2016-11-11 Fri 14:00]
:END:
* PROGRESS Refactor extant CUDA code into a backend
:LOGBOOK:
- State "PROGRESS"   from "TODO"       [2016-11-11 Fri 14:00]
:END:
** TODO Remove `d_' from pointer names in CUDA backend classes ...
** TODO Always check pointers before freeing!
** Questions / thoughts
*** What is a "backend"?
+ A set of classes / functions that performs the computations represented in the front end.
+ Specialises the computations for efficiency
  - but the front end is agnostic about these specialisations
  - consequently, there is a common API
+ Each backend can therefore be thought of as a 'sublibrary'
+ Front end only exposes the structure of the computations, not their implementation
  - but what divides 'structure' from 'implementation'?
    * this is the old 'structure'/'content' problem!...
+ Back end represents the state of the computation, as required by the associated device
*** What is the dispatch mechanism?
+ Each Model is associated with a context, and the context determines the backend
+ The context is associated with a device manager
* PROGRESS Make frontend classes backend-agnostic
:LOGBOOK:
- State "PROGRESS"   from "TODO"       [2016-11-20 Sun 12:10]
:END:
** TODO Think about how to make calls to backend hierarchy irrepetitious (cf, reset_state call).
+ Should backend->reset_state be a virtual method? If so, it always calls the most derived!
** TODO Add macro for getting correct cast of backend pointer
* TODO Update CMake scripts to build CUDA code
* TODO Put external dependencies (eg curand, mgl) into git submodules
* TODO Write plain C++ backend. (Use ViennaCL for linalg acceleration?)
* TODO Write OpenCL backend. (SYCL?)
* TODO Write rate-coded neuron/synapse/model classes.

